#!/bin/bash

#[data]
#    environments = "{{ .chezmoi.homedir }}/envs"
#    opscharm = "{{ .chezmoi.homedir }}/envs/ops-charm"

echo Downloading ops-charm...



git clone github.com/kangco-de/ops-charm {{ .opscharm }} -b devel && echo "TODO: try to update to latest version"
(
    mkvirtualenv ops-charm -r requirements.txt
    deactivate
)

mkvirtualenv {{ .defaultenv }} -r {{ .environments }}/{{ .defaultenv }}/requirements.txt
(
    mkvirtualenv ops-charm -r {{ .opscharm }}/requirements.txt
    deactivate
)


#     virtualenvwrapper_verify_workon_home || return 1
#     virtualenvwrapper_verify_virtualenv || return 1
#     (
#         [ -n "$ZSH_VERSION" ] && setopt SH_WORD_SPLIT
#         virtualenvwrapper_cd "$WORKON_HOME" &&
#         virtualenv $VIRTUALENVWRAPPER_VIRTUALENV_ARGS "$@" &&
#         [ -d "$WORKON_HOME/$envname" ] && \
#             virtualenvwrapper_run_hook "pre_mkvirtualenv" "$envname"
#     )
#     typeset RC=$?
#     [ $RC -ne 0 ] && return $RC
# 
#     # If they passed a help option or got an error from virtualenv,
#     # the environment won't exist.  Use that to tell whether
#     # we should switch to the environment and run the hook.
#     [ ! -d "$WORKON_HOME/$envname" ] && return 0
# 
#     # Now activate the new environment
#     workon "$envname"
# 
#     if [ ! -z "$requirements" ]
#     then
#         pip install -r "$requirements"
#     fi
# 
#     virtualenvwrapper_run_hook "post_mkvirtualenv"
# }
# 
# function virtualenvwrapper_verify_workon_home {
#     RC=0
#     if [ ! -d "$WORKON_HOME/" ]
#     then
#         if [ "$1" != "-q" ]
#         then
#             echo "NOTE: Virtual environments directory $WORKON_HOME does not exist. Creating..." 1>&2
#         fi
#         mkdir -p "$WORKON_HOME"
#         RC=$?
#     fi
#     return $RC
# }
# 
# function virtualenvwrapper_verify_virtualenv {
#     virtualenvwrapper_verify_resource $VIRTUALENVWRAPPER_VIRTUALENV
# }
# 
# function virtualenvwrapper_verify_resource {
#     typeset exe_path="$(command \which "$1" | (unset GREP_OPTIONS; command \grep -v "not found"))"
#     if [ "$exe_path" = "" ]
#     then
#         echo "ERROR: virtualenvwrapper could not find $1 in your path" >&2
#         return 1
#     fi
#     if [ ! -e "$exe_path" ]
#     then
#         echo "ERROR: Found $1 in path as \"$exe_path\" but that does not exist" >&2
#         return 1
#     fi
#     return 0
# }
# 
# function virtualenvwrapper_cd {
#     if [ -n "${BASH:-}" ]
#     then
#         builtin \cd "$@"
#     elif [ -n "${ZSH_VERSION:-}" ]
#     then
#         builtin \cd -q "$@"
#     else
#         command \cd "$@"
#     fi
# }
# 
# function virtualenvwrapper_run_hook {
#     typeset hook_script
#     typeset result
# 
#     hook_script="$(virtualenvwrapper_tempfile ${1}-hook)" || return 1
# 
#     # Use a subshell to run the python interpreter with hook_loader so
#     # we can change the working directory. This avoids having the
#     # Python 3 interpreter decide that its "prefix" is the virtualenv
#     # if we happen to be inside the virtualenv when we start.
#     ( \
#         virtualenvwrapper_cd "$WORKON_HOME" &&
#         "$VIRTUALENVWRAPPER_PYTHON" -m 'virtualenvwrapper.hook_loader' \
#             ${HOOK_VERBOSE_OPTION:-} --script "$hook_script" "$@" \
#     )
#     result=$?
# 
#     if [ $result -eq 0 ]
#     then
#         if [ ! -f "$hook_script" ]
#         then
#             echo "ERROR: virtualenvwrapper_run_hook could not find temporary file $hook_script" 1>&2
#             command \rm -f "$hook_script"
#             return 2
#         fi
#         # cat "$hook_script"
#         source "$hook_script"
#     elif [ "${1}" = "initialize" ]
#     then
#         cat - 1>&2 <<EOF
# virtualenvwrapper.sh: There was a problem running the initialization hooks.
# 
# If Python could not import the module virtualenvwrapper.hook_loader,
# check that virtualenvwrapper has been installed for
# VIRTUALENVWRAPPER_PYTHON=$VIRTUALENVWRAPPER_PYTHON and that PATH is
# set properly.
# EOF
#     fi
#     command \rm -f "$hook_script"
#     return $result
# }
# 
# #:help:workon: list or change working virtualenvs
# function workon {
#     typeset -a in_args
#     typeset -a out_args
# 
#     in_args=( "$@" )
# 
#     if [ -n "$ZSH_VERSION" ]
#     then
#         i=1
#         tst="-le"
#     else
#         i=0
#         tst="-lt"
#     fi
#     typeset cd_after_activate=$VIRTUALENVWRAPPER_WORKON_CD
#     while [ $i $tst $# ]
#     do
#         a="${in_args[$i]}"
#         case "$a" in
#             -h|--help)
#                 virtualenvwrapper_workon_help;
#                 return 0;;
#             -n|--no-cd)
#                 cd_after_activate=0;;
#             -c|--cd)
#                 cd_after_activate=1;;
#             *)
#                 if [ ${#out_args} -gt 0 ]
#                 then
#                     out_args=( "${out_args[@]-}" "$a" )
#                 else
#                     out_args=( "$a" )
#                 fi;;
#         esac
#         i=$(( $i + 1 ))
#     done
# 
#     set -- "${out_args[@]}"
# 
#     typeset env_name="$1"
#     if [ "$env_name" = "" ]
#     then
#         lsvirtualenv -b
#         return 1
#     elif [ "$env_name" = "." ]
#     then
#         # The IFS default of breaking on whitespace causes issues if there
#         # are spaces in the env_name, so change it.
#         IFS='%'
#         env_name="$(basename $(pwd))"
#         unset IFS
#     fi
# 
#     virtualenvwrapper_verify_workon_home || return 1
#     virtualenvwrapper_verify_workon_environment "$env_name" || return 1
# 
#     activate="$WORKON_HOME/$env_name/$VIRTUALENVWRAPPER_ENV_BIN_DIR/activate"
#     if [ ! -f "$activate" ]
#     then
#         echo "ERROR: Environment '$WORKON_HOME/$env_name' does not contain an activate script." >&2
#         return 1
#     fi
# 
#     # Deactivate any current environment "destructively"
#     # before switching so we use our override function,
#     # if it exists, but make sure it's the deactivate function
#     # we set up
#     type deactivate >/dev/null 2>&1
#     if [ $? -eq 0 ]
#     then
#         typeset -f deactivate | grep 'typeset env_postdeactivate_hook' >/dev/null 2>&1
#         if [ $? -eq 0 ]
#         then
#             deactivate
#             unset -f deactivate >/dev/null 2>&1
#         fi
#     fi
# 
#     virtualenvwrapper_run_hook "pre_activate" "$env_name"
# 
#     source "$activate"
# 
#     # Save the deactivate function from virtualenv under a different name
#     virtualenvwrapper_original_deactivate=`typeset -f deactivate | sed 's/deactivate/virtualenv_deactivate/g'`
#     eval "$virtualenvwrapper_original_deactivate"
#     unset -f deactivate >/dev/null 2>&1
# 
#     # Replace the deactivate() function with a wrapper.
#     eval 'deactivate () {
#         typeset env_postdeactivate_hook
#         typeset old_env
# 
#         # Call the local hook before the global so we can undo
#         # any settings made by the local postactivate first.
#         virtualenvwrapper_run_hook "pre_deactivate"
# 
#         env_postdeactivate_hook="$VIRTUAL_ENV/$VIRTUALENVWRAPPER_ENV_BIN_DIR/postdeactivate"
#         old_env=$(basename "$VIRTUAL_ENV")
# 
#         # Call the original function.
#         virtualenv_deactivate $1
# 
#         virtualenvwrapper_run_hook "post_deactivate" "$old_env"
# 
#         if [ ! "$1" = "nondestructive" ]
#         then
#             # Remove this function
#             unset -f virtualenv_deactivate >/dev/null 2>&1
#             unset -f deactivate >/dev/null 2>&1
#         fi
# 
#     }'
# 
#     VIRTUALENVWRAPPER_PROJECT_CD=$cd_after_activate virtualenvwrapper_run_hook "post_activate"
# 
#     return 0
# }
# 